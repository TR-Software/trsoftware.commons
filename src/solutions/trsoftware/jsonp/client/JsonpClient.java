package solutions.trsoftware.jsonp.client;

import com.google.gwt.core.client.GWT;
import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.user.client.Random;
import com.google.gwt.user.client.Timer;
import solutions.trsoftware.commons.client.exceptions.CommonsUncaughtExceptionHandler;

import java.util.HashMap;
import java.util.Map;

/**
 * Usage example:
 *   String gdata = "http://www.google.com/base/feeds/snippets?alt=json-in-script&callback=";
 *   String callbackName = reserveCallbackName();
 *   addCallbackFunction(this, callbackName);
 *   addScript(callbackName, gdata + callbackName);
 *
 * @author Alex
 */
public class JsonpClient {
  /** How long before a call is considered timed out */
  public static final int TIMEOUT_MS = 45000; // 45 seconds
  
  /**
   * Contains the callbacks for which no response has been received yet,
   * so that timeouts may be detected.
   */
  private Map<String, JsonpCallback> outstandingCallbacks = new HashMap<String, JsonpCallback>();

  // TODO: can create a version of the callRemote method that uses token replacement
  // in the URL string to automatically generate and inject a name for the callback function.

  /**
   * Makes a new JSONP call to the given URL, with the given callback function name.
   * @param jsCallbackName The name of a native JS function that the JSONP
   * server will use to return the results of this call.  This name should
   * be generated by calling JsonpClient.reserveCallbackName.
   * @param callback The actual callback action to be given the results of the
   * JSONP call
   */
  public void callRemote(String url, final String jsCallbackName, JsonpCallback callback) {
    addCallbackFunction(jsCallbackName, callback);
    outstandingCallbacks.put(jsCallbackName, callback);
    new Timer() {
      public void run() {
        checkForTimeout(jsCallbackName);
      }
    }.schedule(TIMEOUT_MS);
    addScript(jsCallbackName, url.replaceAll("@@jsCallback@@", jsCallbackName));
  }

  /**
   * Makes a new JSONP call to the given URL.  If the URL contains the substring @@jsCallback@@,
   * this substring is replaced with the name of an automatically generated
   * callback function.
   * This method transparently inserts an auto-generated name of a callback function,
   * and registers it to trigger the given JsonpCallback's execute method.
   * @param callback The actual callback action to be given the results of the
   * JSONP call
   */
  public void callRemote(String url, JsonpCallback callback) {
    String jsCallbackName = reserveCallbackName();
    callRemote(url.replaceAll("@@jsCallback@@", jsCallbackName), jsCallbackName, callback);
  }

  /**
   * Generates and reserves the name of a callback function that can
   * be used in the next JSONP call (via JsonpClient.callRemote).
   * This method is needed by users of this class in order to encode
   * the name of the callback into the URL for the JSONP request.
   * @return
   */
  public String reserveCallbackName() {
    // using a random positive integer to avoid function name clashes
    // using a static counter instead of random doesn't work in GWT's hosted mode
    // (causes HotSpot crash on refresh due to native browser data not being reset)
    return "__gwt_callback" + Random.nextInt(Integer.MAX_VALUE);
  }

  private native void addCallbackFunction(String jsFunctionName, JsonpCallback callback) /*-{
    // must remember the value of "this" for use inside the closure, since
    // "this" will go out of scope by the time the closure is executed
    // (http://code.google.com/support/bin/answer.py?answer=74164&topic=10213)
    var instance = this;
    window[jsFunctionName] = function(result) {
      // wrap primitive results so they can be treated as JavaScriptObject instances
      if (typeof result == "number")
        result = new Number(result)
      else if (typeof result == "boolean")
        result = new Boolean(result)
      instance.@solutions.trsoftware.jsonp.client.JsonpClient::handleResult(Ljava/lang/String;Lsolutions/trsoftware/jsonp/client/JsonpCallback;Lcom/google/gwt/core/client/JavaScriptObject;)(jsFunctionName, callback, result);
      // clean up - remove the function after it's been called
      window[jsFunctionName] = null;
    }
  }-*/;

  /** This method is adding the script tag to the GWT iframe, not the main window */
  private native void addScript(String id, String url) /*-{
    var elem = document.createElement("script");
    elem.setAttribute("id", id);
    elem.setAttribute("type", "text/javascript");
    elem.setAttribute("src", url);
    document.getElementsByTagName("body")[0].appendChild(elem);
  }-*/;

  /** Removes the script tag from the GWT iframe, where it was added */
  private native void removeScript(String id) /*-{
    var elem = document.getElementById(id);
    if (elem != null)
      document.getElementsByTagName("body")[0].removeChild(elem);
  }-*/;

  /**
   * This method is called by the native JS callback function.
   * It simply forwards the JSON result to the registered JsonpCallback instance.
   * and cleans up.
   * @param callbackFunctionName
   * @param callback
   */
  private void handleResult(String callbackFunctionName, JsonpCallback callback, JavaScriptObject result) {
    // Since this method is not called from GWT we must explicitly catch and handle all
    // exceptions thrown by it - otherwise they will be lost (won't propagate
    // down to GWT code)
    // TODO(2/3/2016): instead of calling the the UEH manually, try wrapping the callback function in #addCallbackFunction with $entry (see http://www.gwtproject.org/doc/latest/DevGuideCodingBasicsJSNI.html#calling and the code in com.google.ima.client.js.AdsManager.addNativeEventListener() )
    try {
      // make sure outstandingCallbacks contains an entry with this name, otherwise
      // the function has already been considered timed out
      if (outstandingCallbacks.containsKey(callbackFunctionName)) {
        // cleanup first, to avoid any exception that may be thrown by callback
        cleanUp(callbackFunctionName);
        callback.execute(JSONParser.buildValue(result));
      }
    }
    catch (Throwable e) {
      ((CommonsUncaughtExceptionHandler)GWT.getUncaughtExceptionHandler()).handleException(e, false);
    }
  }

  /**
   * Called by a timer to check if the call is still outstanding.
   * @param callbackFunctionName
   */
  private void checkForTimeout(String callbackFunctionName) {
    JsonpCallback outstandingCallback = outstandingCallbacks.get(callbackFunctionName);
    if (outstandingCallback != null) {
      // cleanup first, to avoid any exception that may be thrown by callback
      cleanUp(callbackFunctionName);
      outstandingCallback.onTimeout();
    }
  }

  private void cleanUp(String callbackFunctionName) {
    outstandingCallbacks.remove(callbackFunctionName);
    removeScript(callbackFunctionName);
  }
}
