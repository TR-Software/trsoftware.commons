/*
 * Copyright 2018 TR Software Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 */

package solutions.trsoftware.tools.experiments.encoding;

import com.google.common.net.UrlEscapers;
import solutions.trsoftware.commons.server.bridge.util.URIComponentEncoderJavaImpl;
import solutions.trsoftware.commons.server.io.SplitterOutputStream;
import solutions.trsoftware.commons.shared.util.MapUtils;
import solutions.trsoftware.commons.shared.util.StringUtils;
import solutions.trsoftware.commons.shared.util.callables.Function1t;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.net.URLEncoder;
import java.util.*;

/**
 * In order to set a server-side cookie that can be reliably read on the client-side with {@link com.google.gwt.user.client.Cookies},
 * the URL-encoding used for the cookie value should be compatible with the JavaScript {@code decodeURIComponent}
 * function (and vice-versa), because {@link com.google.gwt.user.client.Cookies} uses {@code decodeURIComponent}
 * for reading cookie values and {@code encodeURIComponent} for writing them.
 * <p>
 * This class tests some of the different url-encoding implementations available on the server-side, to understand
 * how they differ from the JavaScript {@code decodeURIComponent} function.
 * <p>
 * Upon running this program, several text files will be emitted to the current working directory
 * ({@code System.getProperty("user.dir")}), containing the outputs of each implementation on all ASCII printable chars.
 * Diffing these files will demonstrate how the implementations differ.
 * @author Alex
 * @since 7/20/2018
 */
public class URLEncodingTester {

  private ScriptEngine jsEngine = new ScriptEngineManager().getEngineByName("javascript");

  /**
   * Calls the JavaScript {@code encodeURIComponent} function (using {@link #jsEngine})
   */
  private String encodeURIComponent(String str) throws ScriptException {
    return (String)jsEngine.eval("encodeURIComponent(str)", new SimpleBindings(MapUtils.hashMap("str", str)));
  }

  private void testEncodingLogic() throws Exception {
     testEncodingLogic("JavaScript.encodeURIComponent", this::encodeURIComponent);
     testEncodingLogic(UrlEscapers.class.getName() + ".urlFragmentEscaper", UrlEscapers.urlFragmentEscaper()::escape);
     testEncodingLogic(URLEncoder.class.getName(), (str) -> URLEncoder.encode(str, "UTF-8"));
     testEncodingLogic(URIComponentEncoderJavaImpl.class.getName(), URIComponentEncoderJavaImpl.getInstance()::encode);
   }

   private static void testEncodingLogic(String encoderName, Function1t<String, String, Exception> encoderFcn) throws Exception {
     String outFilename = encoderName + ".txt";
     File outFile = new File(outFilename);  // will be in the "working directory" of this java process
     try (PrintStream out = SplitterOutputStream.teeToFile(outFile)) {
       out.println("================================================================================");
       out.printf("Output from %s   <generated by %s on %s>", encoderName, URLEncodingTester.class.getName(), new Date());
       out.println("================================================================================");
       Set<Character> safeChars = new LinkedHashSet<>();
       Map<Character, String> escapedChars = new LinkedHashMap<>();
       for (int i = 0; i < StringUtils.ASCII_PRINTABLE_CHARS.length(); i++) {
         char c = StringUtils.ASCII_PRINTABLE_CHARS.charAt(i);
         String cStr = String.valueOf(c);
         String cEncoded = encoderFcn.call(cStr);
         boolean escaped = false;
         if (cStr.equals(cEncoded)) {
           safeChars.add(c);
         }
         else {
           escaped = true;
           escapedChars.put(c, cEncoded);
         }
         out.printf("'%s' -> '%s' %s%n", cStr, cEncoded, escaped ? "(escaped)" : "");
       }
       out.println("--------------------------------------------------------------------------------");
       out.println("safeChars = " + safeChars);
       out.println("escapedChars = " + escapedChars.keySet());
       for (Map.Entry<Character, String> entry : escapedChars.entrySet()) {
         out.printf("'%c' -> '%s'%n", entry.getKey(), entry.getValue());
       }
     }
     System.out.println("--------------------------------------------------------------------------------");
     System.out.println("* output written to " + outFile.getAbsolutePath());
   }

  public static void main(String[] args) throws Exception {
    new URLEncodingTester().testEncodingLogic();
  }

}
